---
title: "Learning simulation studies"
subtitle: "Lesson 2"
author: "Template by Ian Hussey, additions by [student's name]"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    code_folding: hide
    highlight: haddock
    theme: flatly
    toc: yes
    toc_float: yes
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(message = FALSE, 
                      warning = FALSE)

# disable scientific notation
options(scipen=999)

```

```{r dependencies and settings}

# dependencies
library(tidyverse)
library(scales)
library(knitr)
library(kableExtra)
library(janitor)
# install.packages("devtools")
# library(devtools)
# devtools::install_github("ianhussey/simulateR")
library(simulateR) # available from github - uncomment the above lines to install

# set seed
set.seed(42)

```

# Parameter recovery of $\mu$ and $\sigma$

The previous lesson finished with code for a simulation to recover $\mu$ and $\sigma$ across a large number of iterations of smaller samples. Here is the code again:

```{r}

set.seed(42)

# new values 
n_samples <- 100
n_iterations <- 10000
mu <- 0.33
sigma <- 1

# create two new results vectors
results_means <- numeric(n_iterations)
results_sds <- numeric(n_iterations)

for(i in 1:n_iterations){
  # generate data sampled from a normal population using rnorm
  simulated_scores <- 
    rnorm(n = n_samples, 
          mean = mu, 
          sd = sigma)
  
  # compute the mean for this simulation and store it 
  # in the `i`th element of each results vector
  results_means[i] <- mean(simulated_scores)
  results_sds[i] <- sd(simulated_scores)
}

# compute the mean of means
mean(results_means) |> round_half_up(2)
# check that the mean of sample means is equal to the population mean (mu)
mean(results_means) |> round_half_up(2) == mu

# compute the mean of SDs
mean(results_sds) |> round_half_up(2)
# check that the mean of sample SDs is equal to the population SD (sigma)
mean(results_sds) |> round_half_up(2) == sigma

```

We also noted that it is important to vary the simulation parameters. **In the context of a simulation, this is what constitutes an experiment**: parameters are systematically varied, and results are observed. Publications reporting such results are typically called "simulation studies", but it might be more accurate to call (at least some of them) "simulation experiments". 

Varying simulation parameters in order to observe results can (a) provide evidence that (elements of) your simulation are working correctly, and/or (b) provide insights into the thing you are varying and how it changes across input parameters or other conditions.

# Running simulations with different parameters more easily

[sth about instructing the user to run the above multiple times with different inputs, or showing long-hand that examining different parameters values requires you to duplicate the code a lot.]

In lesson 1, we used a for loop to run be able to easily run an arbitrary number of iterations of a simulation. 

Comparably, if we want to run the same simulation an arbitrary number of times, perhaps using different population parameters, maybe there are other changes we could make to the code to make it possible to do this.

To do this, we'll need to first take a step back and talk about functions.

# Functions

Writing R code involves making frequent use of functions. Functions take inputs, do things with them or based on them, and return outputs. 

`mean()` is a variable. It takes a vector of numeric values (its input) and returns their average. 

`for()` is a variable,

We can write our own variables too, when there isn't one that does exactly what we want.

simple example

more complex example

convert simulation into a function. maybe need to work more on it returning a data frame rather than vectors first?

make very clear that this process of abstracting and iterating is how you write this stuff. you dont start writing "function()" and just know what youre doing.

```{r}



```

# Session info

```{r}

sessionInfo()

```




